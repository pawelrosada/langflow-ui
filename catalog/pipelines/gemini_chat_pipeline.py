"""
Gemini Chat Pipeline for Open WebUI
Integration with Google Gemini Pro through Langflow
"""

import os
import time
from datetime import datetime
from logging import getLogger
from typing import Generator, Iterator, List, Union

import httpx
from pydantic import BaseModel, Field

logger = getLogger(__name__)
logger.setLevel("DEBUG")

class Pipeline:
    class Valves(BaseModel):
        LANGFLOW_BASE_URL: str = Field(
            default="http://langflow:7860",
            description="Base URL for Langflow API"
        )
        WORKFLOW_ID: str = Field(
            default="gemini-chat-basic",
            description="Gemini workflow ID in Langflow (endpoint_name)"
        )
        RATE_LIMIT: int = Field(
            default=5,
            description="Requests per second limit"
        )
        TIMEOUT: int = Field(
            default=30,
            description="Timeout in seconds for Langflow requests"
        )

    def __init__(self):
        self.name = "Gemini Chat Pipeline"
        self.valves = self.Valves(
            **{k: os.getenv(k, v.default) for k, v in self.Valves.model_fields.items()}
        )

    async def on_startup(self):
        logger.info(f"🚀 Started pipeline: {self.name}")
        logger.info(f"🔗 Langflow URL: {self.valves.LANGFLOW_BASE_URL}")
        logger.info(f"🔄 Workflow ID: {self.valves.WORKFLOW_ID}")
    
    async def on_shutdown(self): 
        logger.info(f"🛑 Stopped pipeline: {self.name}")

    def rate_check(self, dt_start: datetime):
        """Checks and enforces rate limiting"""
        diff = (datetime.now() - dt_start).total_seconds()
        buffer = 1 / self.valves.RATE_LIMIT
        if diff < buffer: 
            time.sleep(buffer - diff)

    def pipe(self, user_message: str, model_id: str, messages: List[dict], body: dict) -> Union[str, Generator, Iterator]:
        """
        Main pipeline function - forwards message to Langflow with Gemini
        """
        logger.debug(f"📨 Processing message through {self.name}")
        logger.debug(f"📋 Message: {user_message[:100]}...")
        
        dt_start = datetime.now()
        
        try:
            result = "".join([chunk for chunk in self.call_langflow(user_message, dt_start)])
            logger.info(f"✅ Response generated by Gemini (length: {len(result)})")
            return result
        except Exception as e:
            logger.error(f"❌ Error in Gemini pipeline: {e}")
            return f"🚨 **Gemini Pipeline Error**: {str(e)}"

    def call_langflow(self, prompt: str, dt_start: datetime) -> Generator:
        """
        Calls Langflow API with Gemini workflow
        """
        self.rate_check(dt_start)
        
        # URL to specific Gemini workflow
        url = f"{self.valves.LANGFLOW_BASE_URL}/api/v1/run/{self.valves.WORKFLOW_ID}?stream=false"
        
        payload = {
            "input_value": prompt,
            "output_type": "chat",
            "input_type": "chat"
        }
        
        headers = {
            "Content-Type": "application/json"
        }
        
        logger.debug(f"🔗 Calling Langflow: {url}")
        logger.debug(f"📦 Payload: {payload}")
        
        try:
            with httpx.Client(timeout=self.valves.TIMEOUT) as client:
                response = client.post(url, json=payload, headers=headers)
                response.raise_for_status()
                
                data = response.json()
                logger.debug(f"📥 Langflow response: {data}")
                
                # Extract response text from Langflow structure
                text = (
                    data.get("outputs", [{}])[0]
                        .get("outputs", [{}])[0]
                        .get("results", {})
                        .get("message", {})
                        .get("text", "No response from Gemini")
                )
                
                if text:
                    yield f"🤖 **Gemini Pro**: {text}"
                else:
                    yield "🚨 **Gemini Error**: No response received from model"
                    
        except httpx.TimeoutException:
            logger.error(f"⏰ Timeout while connecting to Langflow")
            yield "🚨 **Gemini Error**: Response timeout exceeded"
            
        except httpx.HTTPStatusError as e:
            logger.error(f"🚫 HTTP error from Langflow: {e.response.status_code}")
            yield f"🚨 **Gemini Error**: Server error ({e.response.status_code})"
            
        except Exception as e:
            logger.error(f"❌ Unexpected Langflow error: {e}")
            yield f"🚨 **Gemini Error**: {str(e)}"