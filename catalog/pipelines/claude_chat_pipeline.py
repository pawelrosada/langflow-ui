"""
Claude-3.5 Chat Pipeline for Open WebUI
Integration with Anthropic Claude-3.5 Sonnet through Langflow
"""

import os
import time
from datetime import datetime
from logging import getLogger
from typing import Generator, Iterator, List, Union

import httpx
from pydantic import BaseModel, Field

logger = getLogger(__name__)
logger.setLevel("DEBUG")

class Pipeline:
    class Valves(BaseModel):
        LANGFLOW_BASE_URL: str = Field(
            default="http://langflow:7860",
            description="Base URL for Langflow API"
        )
        WORKFLOW_ID: str = Field(
            default="claude3-chat-basic",
            description="Claude-3.5 workflow ID in Langflow (endpoint_name)"
        )
        RATE_LIMIT: int = Field(
            default=5,
            description="Requests per second limit"
        )
        TIMEOUT: int = Field(
            default=30,
            description="Timeout in seconds for Langflow requests"
        )

    def __init__(self):
        self.name = "Claude-3.5 Sonnet Chat Pipeline"
        self.valves = self.Valves(
            **{k: os.getenv(k, v.default) for k, v in self.Valves.model_fields.items()}
        )

    async def on_startup(self):
        logger.info(f"🚀 Started pipeline: {self.name}")
        logger.info(f"🔗 Langflow URL: {self.valves.LANGFLOW_BASE_URL}")
        logger.info(f"🔄 Workflow ID: {self.valves.WORKFLOW_ID}")
    
    async def on_shutdown(self): 
        logger.info(f"🛑 Stopped pipeline: {self.name}")

    def rate_check(self, dt_start: datetime):
        """Checks and enforces rate limiting"""
        diff = (datetime.now() - dt_start).total_seconds()
        buffer = 1 / self.valves.RATE_LIMIT
        if diff < buffer: 
            time.sleep(buffer - diff)

    def pipe(self, user_message: str, model_id: str, messages: List[dict], body: dict) -> Union[str, Generator, Iterator]:
        """
        Main pipeline function - forwards message to Langflow with Claude-3.5
        """
        logger.debug(f"📨 Processing message through {self.name}")
        logger.debug(f"📋 Message: {user_message[:100]}...")
        
        dt_start = datetime.now()
        
        try:
            result = "".join([chunk for chunk in self.call_langflow(user_message, dt_start)])
            logger.info(f"✅ Response generated by Claude-3.5 (length: {len(result)})")
            return result
        except Exception as e:
            logger.error(f"❌ Error in pipeline Claude-3.5: {e}")
            return f"🚨 **Claude-3.5 Pipeline Error**: {str(e)}"

    def call_langflow(self, prompt: str, dt_start: datetime) -> Generator:
        """
        Calls Langflow API with workflow Claude-3.5
        """
        self.rate_check(dt_start)
        
        # URL to specific workflow Claude-3.5
        url = f"{self.valves.LANGFLOW_BASE_URL}/api/v1/run/{self.valves.WORKFLOW_ID}?stream=false"
        
        payload = {
            "input_value": prompt,
            "output_type": "chat",
            "input_type": "chat"
        }
        
        headers = {
            "Content-Type": "application/json"
        }
        
        logger.debug(f"🔗 Calling Langflow: {url}")
        logger.debug(f"📦 Payload: {payload}")
        
        try:
            with httpx.Client(timeout=self.valves.TIMEOUT) as client:
                response = client.post(url, json=payload, headers=headers)
                response.raise_for_status()
                
                data = response.json()
                logger.debug(f"📥 Langflow response: {data}")
                
                # Extract response text from Langflow structure
                text = (
                    data.get("outputs", [{}])[0]
                        .get("outputs", [{}])[0]
                        .get("results", {})
                        .get("message", {})
                        .get("text", "No response from Claude-3.5")
                )
                
                if text:
                    yield f"🤖 **Claude-3.5 Sonnet**: {text}"
                else:
                    yield "🚨 **Claude-3.5 Error**: No response received from model"
                    
        except httpx.TimeoutException:
            logger.error(f"⏰ Timeout while connecting to Langflow")
            yield "🚨 **Claude-3.5 Error**: Response timeout exceeded"
            
        except httpx.HTTPStatusError as e:
            logger.error(f"🚫 HTTP error from Langflow: {e.response.status_code}")
            yield f"🚨 **Claude-3.5 Error**: Server error ({e.response.status_code})"
            
        except Exception as e:
            logger.error(f"❌ Unexpected Langflow error: {e}")
            yield f"🚨 **Claude-3.5 Error**: {str(e)}"